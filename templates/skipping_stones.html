{% extends "base.html" %}

{% block title %}Skipping Stones{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-md-8">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h3 class="mb-0">
                        <i class="fas fa-circle me-2"></i>Game Board
                    </h3>
                </div>
                <div class="card-body">
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <p class="text-muted">Click a stone to select it, then click a valid destination to make a move.</p>
                        </div>
                        <div class="col-md-6 text-end">
                            <button id="shareBtn" class="btn btn-info" style="display: none;">
                                <i class="fas fa-share-alt me-2"></i>Share Achievement
                            </button>
                            <button id="saveBtn" class="btn btn-success" style="min-width: 120px;">
                                <i class="fas fa-save me-2"></i>Save Game
                            </button>
                            <button id="resetBtn" class="btn btn-warning">
                                <i class="fas fa-redo me-2"></i>Reset Game
                            </button>
                            <button id="undoBtn" class="btn btn-secondary">
                                <i class="fas fa-undo me-2"></i>Undo
                            </button>
                            <button id="hintBtn" class="btn btn-outline-info">
                                <i class="fas fa-lightbulb me-2"></i>Hint
                            </button>
                        </div>
                    </div>

                    <div class="game-board-container">
                        <div class="level-indicator">
                            <span class="level-badge">Level: <span id="currentLevel">1</span></span>
                        </div>
                        <div id="gameBoard" class="game-board"></div>
                    </div>

                    <div class="row mt-3">
                        <div class="col-md-6">
                            <div class="card bg-light">
                                <div class="card-body">
                                    <h6 class="card-title">
                                        <i class="fas fa-info-circle text-info me-2"></i>Game Rules
                                    </h6>
                                    <ul class="list-unstyled mb-0">
                                        <li><i class="fas fa-check text-success me-2"></i>Click a stone to select it</li>
                                        <li><i class="fas fa-check text-success me-2"></i>Click a valid destination to jump to</li>
                                        <li><i class="fas fa-check text-success me-2"></i>Stone must jump over another stone when making a move</li>
                                        <li><i class="fas fa-check text-success me-2"></i>Jumped stone is removed</li>
                                        <li><i class="fas fa-check text-success me-2"></i>Goal: Leave only one stone</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card bg-light">
                                <div class="card-body">
                                    <h6 class="card-title">
                                        <i class="fas fa-trophy text-warning me-2"></i>Game Stats
                                    </h6>
                                    <div class="row text-center">
                                        <div class="col-4">
                                            <h4 id="movesCount" class="text-primary">0</h4>
                                            <small class="text-muted">Moves</small>
                                        </div>
                                        <div class="col-4">
                                            <h4 id="marblesLeft" class="text-success">0</h4>
                                            <small class="text-muted">Stones Left</small>
                                        </div>
                                        <div class="col-4">
                                            <h4 id="gameStatus" class="text-info">Playing</h4>
                                            <small class="text-muted">Status</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-4">
            <!-- Board Shape Selector -->
            <div class="card mb-3">
                <div class="card-header bg-dark text-white">
                    <h5 class="mb-0">
                        <i class="fas fa-shapes me-2"></i>Board Shape
                    </h5>
                </div>
                <div class="card-body p-2">
                    <div id="shapeSelector" class="shape-selector d-flex flex-wrap gap-1">
                        <!-- Shape buttons loaded dynamically -->
                    </div>
                    <div class="mt-2">
                        <button id="diagonalBtn" class="btn btn-outline-secondary btn-sm" title="Allow diagonal jumps (D)">
                            <i class="fas fa-arrows-alt me-1"></i>Diagonal Moves
                        </button>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header bg-success text-white">
                    <h5 class="mb-0">
                        <i class="fas fa-puzzle-piece me-2"></i>Puzzle Configurations
                    </h5>
                </div>
                <div class="card-body">
                    <div id="configurations" class="config-list">
                        <!-- Configurations will be loaded here -->
                    </div>
                </div>
            </div>

            <div class="card mt-3">
                <div class="card-header">
                    <h6 class="mb-0">
                        <i class="fas fa-history text-secondary me-2"></i>Move History
                    </h6>
                </div>
                <div class="card-body">
                    <div id="moveHistory" class="move-history">
                        <p class="text-muted text-center">No moves yet</p>
                    </div>
                </div>
            </div>

            <div class="card mt-3" id="userStatsCard" style="display: none;">
                <div class="card-header bg-info text-white">
                    <h6 class="mb-0">
                        <i class="fas fa-user-chart me-2"></i>Your Progress
                    </h6>
                </div>
                <div class="card-body">
                    <div id="userStats" class="user-stats">
                        <div class="row text-center">
                            <div class="col-6">
                                <h5 id="completedLevels" class="text-success">0</h5>
                                <small class="text-muted">Levels Completed</small>
                            </div>
                            <div class="col-6">
                                <h5 id="totalLevels" class="text-primary">7</h5>
                                <small class="text-muted">Total Levels</small>
                            </div>
                        </div>
                        <div class="progress mt-3">
                            <div id="progressBar" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Share Modal -->
<div class="modal fade" id="shareModal" tabindex="-1" aria-labelledby="shareModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="shareModalLabel">
                    <i class="fas fa-share-alt me-2"></i>Share Your Achievement
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center">
                <div id="shareImageContainer">
                    <p class="text-muted">Generating your achievement image...</p>
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" id="downloadShareBtn">
                    <i class="fas fa-download me-2"></i>Download Image
                </button>
                <button type="button" class="btn btn-info" id="nativeShareBtn" style="display: none;">
                    <i class="fas fa-share me-2"></i>Share
                </button>
            </div>
        </div>
    </div>
</div>

<style>
.game-board-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 20px 0;
}

.level-indicator {
    margin-bottom: 15px;
}

.level-badge {
    background: linear-gradient(135deg, #007bff, #0056b3);
    color: white;
    padding: 10px 20px;
    border-radius: 25px;
    font-weight: bold;
    font-size: 1.2em;
    box-shadow: 0 4px 12px rgba(0, 123, 255, 0.4);
    display: inline-block;
    border: 2px solid rgba(255, 255, 255, 0.3);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.game-board {
    display: grid;
    gap: 2px;
    background: #ddd;
    padding: 10px;
    border-radius: 8px;
    max-width: 500px;
    width: 100%;
    margin: 0 auto;
}

.cell {
    aspect-ratio: 1;
    border: 1px solid #999;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
    background: #f8f9fa;
    font-size: clamp(0.6em, 2.5vw, 1em);
}

.cell:hover {
    background: #e9ecef;
}

.cell.marble {
    background: #007bff;
    border-radius: 50%;
    color: white;
    font-weight: bold;
}

.cell.selected {
    background: #28a745;
    border: 2px solid #20c997;
    animation: selected-pulse 1.5s ease-in-out infinite;
}

@keyframes selected-pulse {
    0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 4px rgba(40, 167, 69, 0.4);
    }
    50% {
        transform: scale(1.08);
        box-shadow: 0 0 12px rgba(40, 167, 69, 0.7);
    }
}

.cell.valid-move {
    background: #ffc107;
    border: 2px solid #fd7e14;
}

.cell.invalid {
    background-color: #6c757d !important;
    cursor: not-allowed !important;
    opacity: 0.6 !important;
    border-color: #495057 !important;
}

.cell.hint-source {
    background: #e83e8c !important;
    border: 2px solid #c2185b !important;
    animation: hint-pulse 1.5s ease-in-out infinite;
}

.cell.hint-destination {
    background: #f8f9fa;
    border: 3px dashed #e83e8c !important;
    animation: hint-pulse 1.5s ease-in-out infinite;
}

@keyframes hint-pulse {
    0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 4px rgba(232, 62, 140, 0.4);
    }
    50% {
        transform: scale(1.08);
        box-shadow: 0 0 12px rgba(232, 62, 140, 0.7);
    }
}

.shape-selector .shape-btn {
    padding: 6px 14px;
    border: 2px solid #dee2e6;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s;
    background: #f8f9fa;
    font-size: 0.85em;
    font-weight: 500;
}

.shape-selector .shape-btn:hover {
    border-color: #007bff;
    background: #e7f1ff;
}

.shape-selector .shape-btn.active {
    background: #343a40;
    color: white;
    border-color: #343a40;
}

.config-item {
    padding: 10px;
    margin: 5px 0;
    border: 1px solid #dee2e6;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.2s;
}

.config-item:hover {
    background: #f8f9fa;
    border-color: #007bff;
}

.config-item.active {
    background: #007bff;
    color: white;
    border-color: #0056b3;
    box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
    transform: translateY(-1px);
}

.config-item.completed {
    border-color: #28a745;
    background: #f8fff9;
}

.config-item.completed:hover {
    background: #e8f5e8;
    border-color: #20c997;
}

.move-history {
    max-height: 200px;
    overflow-y: auto;
}

.move-item {
    padding: 5px;
    margin: 2px 0;
    background: #f8f9fa;
    border-radius: 3px;
    font-size: 0.9em;
}

@media (max-width: 768px) {
    .game-board {
        max-width: 100%;
    }
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

/* Game Board Login Button Styling */
.google-login-game-btn {
    background: linear-gradient(135deg, #007bff, #0056b3) !important;
    background-size: 200% 200% !important;
    animation: blue-gradient-game 3s ease infinite !important;
    color: white !important;
    border: none !important;
    box-shadow: 0 6px 20px rgba(0, 123, 255, 0.5) !important;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
    position: relative !important;
    overflow: hidden !important;
    font-weight: 600 !important;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4) !important;
}

.google-login-game-btn::before {
    content: '' !important;
    position: absolute !important;
    top: 0 !important;
    left: -100% !important;
    width: 100% !important;
    height: 100% !important;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent) !important;
    transition: left 0.6s ease !important;
}

.google-login-game-btn:hover {
    transform: translateY(-2px) scale(1.03) !important;
    box-shadow: 0 10px 30px rgba(0, 123, 255, 0.7) !important;
    background-size: 150% 150% !important;
}

.google-login-game-btn:hover::before {
    left: 100% !important;
}

.google-login-game-btn:active {
    transform: translateY(0) scale(1.01) !important;
    box-shadow: 0 4px 15px rgba(0, 123, 255, 0.6) !important;
}

@keyframes blue-gradient-game {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.google-login-game-btn .fab.fa-google {
    background: linear-gradient(135deg, #4285f4, #34a853, #fbbc05, #ea4335) !important;
    background-size: 200% 200% !important;
    -webkit-background-clip: text !important;
    -webkit-text-fill-color: transparent !important;
    background-clip: text !important;
    animation: google-icon-pulse 2s ease-in-out infinite !important;
    font-size: 1.1em !important;
    filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3)) !important;
}

@keyframes google-icon-pulse {
    0%, 100% {
        background-size: 200% 200%;
        transform: scale(1);
    }
    50% {
        background-size: 150% 150%;
        transform: scale(1.1);
    }
}
</style>

<script>
class SkippingStonesGame {
    constructor() {
        // Shape and config state
        this.shapes = {};          // shape_id -> { name, rows, cols, validCells, center, levels }
        this.shapeOrder = [];
        this.currentShape = 'wiegleb';
        this.validCellsSet = new Set();

        this.board = [];
        this.selectedMarble = null;
        this.moveHistory = [];
        this.currentConfig = 'level1';
        this.configurations = {};  // current shape's levels
        this.completedLevels = [];
        this.isUserLoggedIn = false;
        this.userEmail = null;
        this.userName = null;
        this.levelStates = {}; // Store state for each level (namespaced: "shape:level")
        this.hasUnsavedChanges = false;
        this.hintsEnabled = false;
        this.currentHint = null;
        this.hintRequestId = 0;
        this.allowDiagonals = false;
        this.init();
    }

    // --- Namespaced key helpers ---
    _stateKey(configKey, shapeId) {
        shapeId = shapeId || this.currentShape;
        return `${shapeId}:${configKey}`;
    }

    // Validate that each level's move history is independent
    validateLevelStates() {
        console.log('Validating level states...');
        for (const [levelKey, levelState] of Object.entries(this.levelStates)) {
            console.log(`Level ${levelKey}:`);
            console.log(`  - Board: ${levelState.board ? 'present' : 'missing'}`);
            console.log(`  - MoveHistory: ${levelState.moveHistory ? levelState.moveHistory.length : 0} moves`);
        }
    }

    // Save current level state to session storage
    saveLevelState() {
        const stateKey = this._stateKey(this.currentConfig);
        const levelState = {
            board: this.board,
            moveHistory: this.moveHistory
        };
        this.levelStates[stateKey] = levelState;

        const sessionData = {
            levelStates: this.levelStates,
            currentShape: this.currentShape,
            timestamp: Date.now(),
            userEmail: this.userEmail || 'anonymous'
        };
        sessionStorage.setItem('skippingStonesLevelStates', JSON.stringify(sessionData));
        console.log('Saving level state for:', stateKey, 'with', this.moveHistory.length, 'moves');
    }

    // Load level state from session storage
    loadLevelState(configKey) {
        const savedStates = sessionStorage.getItem('skippingStonesLevelStates');
        if (savedStates) {
            try {
                const sessionData = JSON.parse(savedStates);

                if (sessionData.userEmail && this.userEmail && sessionData.userEmail !== this.userEmail) {
                    console.log('Session data belongs to different user, clearing');
                    this.clearSessionStorage();
                    return false;
                }

                if (sessionData.timestamp && (Date.now() - sessionData.timestamp) > 24 * 60 * 60 * 1000) {
                    console.log('Session data is too old, clearing');
                    this.clearSessionStorage();
                    return false;
                }

                this.levelStates = sessionData.levelStates || {};
                const stateKey = this._stateKey(configKey);
                const levelState = this.levelStates[stateKey];
                if (levelState) {
                    console.log('Loading level state for:', stateKey, 'with', levelState.moveHistory ? levelState.moveHistory.length : 0, 'moves');
                    this.board = levelState.board;
                    this.moveHistory = levelState.moveHistory || [];
                    return true;
                }
            } catch (error) {
                console.error('Error loading level states:', error);
            }
        }
        return false;
    }

    // Clear level state (for reset functionality)
    clearLevelState(configKey) {
        const stateKey = this._stateKey(configKey);
        if (this.levelStates[stateKey]) {
            delete this.levelStates[stateKey];
            const sessionData = {
                levelStates: this.levelStates,
                currentShape: this.currentShape,
                timestamp: Date.now(),
                userEmail: this.userEmail || 'anonymous'
            };
            sessionStorage.setItem('skippingStonesLevelStates', JSON.stringify(sessionData));
        }
    }

    // Clear all session storage
    clearSessionStorage() {
        sessionStorage.removeItem('skippingStonesLevelStates');
        localStorage.removeItem('skippingStones_backup');
        this.levelStates = {};
        this.completedLevels = [];
        this.moveHistory = [];
        this.selectedMarble = null;
        console.log('Cleared session storage and game state');
    }

    createBoard() {
        const shape = this.shapes[this.currentShape];
        const rows = shape ? shape.rows : 9;
        const cols = shape ? shape.cols : 9;
        const board = [];
        for (let i = 0; i < rows; i++) {
            board[i] = [];
            for (let j = 0; j < cols; j++) {
                board[i][j] = false;
            }
        }
        return board;
    }

    _rebuildValidCellsSet() {
        const shape = this.shapes[this.currentShape];
        this.validCellsSet = new Set();
        if (shape && shape.validCells) {
            for (const [r, c] of shape.validCells) {
                this.validCellsSet.add(`${r},${c}`);
            }
        }
    }

    _isValidCell(r, c) {
        return this.validCellsSet.has(`${r},${c}`);
    }

    async init() {
        await this.loadConfigurations();
        this.setupEventListeners();
        this.setupActivityTracking();

        await this.checkUserLoginStatus();

        if (!this.isUserLoggedIn) {
            const savedStates = sessionStorage.getItem('skippingStonesLevelStates');
            if (savedStates) {
                try {
                    const sessionData = JSON.parse(savedStates);
                    if (sessionData.userEmail && sessionData.userEmail !== 'anonymous') {
                        console.log('Detected session data from logged-out user, clearing');
                        this.clearSessionStorage();
                    }
                } catch (error) {
                    console.error('Error checking session data:', error);
                    this.clearSessionStorage();
                }
            }

            this.loadConfiguration(this.currentConfig, true);
            this.updateDisplay();
            this.updateMoveHistory();
        }

        if (this.isUserLoggedIn) {
            await this.loadUserGameState();
        } else {
            const restoredFromBackup = this.loadGameStateFromLocalStorage();

            if (!restoredFromBackup) {
                const savedStates = sessionStorage.getItem('skippingStonesLevelStates');
                if (savedStates) {
                    try {
                        const sessionData = JSON.parse(savedStates);

                        if (sessionData.userEmail && this.userEmail && sessionData.userEmail !== this.userEmail) {
                            console.log('Session data belongs to different user, clearing');
                            this.clearSessionStorage();
                        } else if (sessionData.timestamp && (Date.now() - sessionData.timestamp) > 24 * 60 * 60 * 1000) {
                            console.log('Session data is too old, clearing');
                            this.clearSessionStorage();
                        } else {
                            this.levelStates = sessionData.levelStates || {};
                            // Restore shape from session
                            if (sessionData.currentShape && this.shapes[sessionData.currentShape]) {
                                this.currentShape = sessionData.currentShape;
                                this._rebuildValidCellsSet();
                                this.configurations = this.shapes[this.currentShape].levels;
                                this.renderShapeSelector();
                                this.renderConfigurations();
                            }
                        }
                    } catch (error) {
                        console.error('Error loading level states:', error);
                        this.levelStates = {};
                    }
                }

                const hasSavedState = this.loadLevelState(this.currentConfig);
                if (hasSavedState) {
                    this.updateDisplay();
                    this.updateMoveHistory();
                } else {
                    this.loadConfiguration(this.currentConfig);
                }
            }
        }

        this.updateDisplay();
        this.highlightActiveConfiguration();
        this.updateUserStats();
        this.updateSaveButtonState();
    }

    async loadConfigurations() {
        try {
            const response = await fetch('/api/skipping-stones/configs');
            const data = await response.json();
            this.shapes = data.shapes;
            this.shapeOrder = data.shapeOrder;

            // Set up initial shape
            this._rebuildValidCellsSet();
            this.configurations = this.shapes[this.currentShape].levels;
            this.allowDiagonals = this.shapes[this.currentShape].defaultDiagonals || false;
            this.updateDiagonalButtonState();
            this.board = this.createBoard();

            this.renderShapeSelector();
            this.renderConfigurations();
        } catch (error) {
            console.error('Failed to load configurations:', error);
        }
    }

    renderShapeSelector() {
        const container = document.getElementById('shapeSelector');
        container.innerHTML = '';

        for (const shapeId of this.shapeOrder) {
            const shape = this.shapes[shapeId];
            const btn = document.createElement('button');
            btn.className = 'shape-btn' + (shapeId === this.currentShape ? ' active' : '');
            btn.textContent = shape.name;
            btn.onclick = () => this.selectShape(shapeId);
            container.appendChild(btn);
        }
    }

    selectShape(shapeId) {
        if (shapeId === this.currentShape) return;

        // Save current state before switching
        this.saveLevelState();

        this.currentShape = shapeId;
        this.allowDiagonals = this.shapes[shapeId].defaultDiagonals || false;
        this.updateDiagonalButtonState();
        this._rebuildValidCellsSet();
        this.configurations = this.shapes[shapeId].levels;

        // Update grid columns for new shape
        const shape = this.shapes[shapeId];
        const boardElement = document.getElementById('gameBoard');
        boardElement.style.gridTemplateColumns = `repeat(${shape.cols}, 1fr)`;

        this.renderShapeSelector();
        this.renderConfigurations();

        // Load first level of new shape
        const firstLevel = Object.keys(this.configurations)[0];
        this.currentConfig = firstLevel;

        const hasSavedState = this.loadLevelState(firstLevel);
        if (hasSavedState) {
            this.updateDisplay();
            this.updateMoveHistory();
        } else {
            this.loadConfiguration(firstLevel, false);
        }

        const levelNumber = firstLevel.replace('level', '');
        document.getElementById('currentLevel').textContent = levelNumber;
        this.highlightActiveConfiguration();
        this.checkGameStatus();

        if (this.hintsEnabled) {
            this.cancelHintSolving();
        }
        this.updateUserStats();
    }

    renderConfigurations() {
        const container = document.getElementById('configurations');
        container.innerHTML = '';

        Object.entries(this.configurations).forEach(([key, config]) => {
            const div = document.createElement('div');
            div.className = 'config-item';
            if (key === this.currentConfig) {
                div.classList.add('active');
            }

            const stateKey = this._stateKey(key);
            const isCompleted = this.completedLevels.includes(stateKey);
            const completedIcon = isCompleted ? '<i class="fas fa-check-circle text-success me-2"></i>' : '';
            const completedClass = isCompleted ? 'completed' : '';

            div.innerHTML = `
                ${completedIcon}<strong>${config.name}</strong><br>
                <small class="text-muted">${config.description}</small>
                ${isCompleted ? '<br><small class="text-success">&#10003; Completed</small>' : ''}
            `;

            if (completedClass) {
                div.classList.add(completedClass);
            }

            div.onclick = () => this.selectConfiguration(key);
            container.appendChild(div);
        });
    }

    selectConfiguration(configKey) {
        console.log('Selecting configuration:', configKey, 'from current:', this.currentConfig);

        if (this.currentConfig === configKey) {
            this.highlightActiveConfiguration();
            return;
        }

        console.log('Saving current level state before switching');
        this.saveLevelState();

        this.currentConfig = configKey;

        const hasSavedState = this.loadLevelState(configKey);

        if (hasSavedState) {
            console.log('Using saved state for', configKey);
            this.updateDisplay();
            this.updateMoveHistory();
        } else {
            console.log('Loading fresh configuration for', configKey);
            this.loadConfiguration(configKey, false);
        }

        const levelNumber = configKey.replace('level', '');
        document.getElementById('currentLevel').textContent = levelNumber;

        this.highlightActiveConfiguration();
        this.checkGameStatus();

        if (this.hintsEnabled) {
            this.cancelHintSolving();
        }
        this.updateUserStats();
    }

    async loadConfiguration(configKey, preserveHistory = false) {
        console.log('Loading configuration:', configKey, 'preserveHistory:', preserveHistory);

        this.currentConfig = configKey;
        this.resetBoard();

        const config = this.configurations[configKey];
        if (config && config.marbles) {
            config.marbles.forEach(([row, col]) => {
                this.board[row][col] = true;
            });
        }

        this.updateDisplay();

        if (!preserveHistory) {
            this.clearHistory();
        }

        const levelNumber = configKey.replace('level', '');
        document.getElementById('currentLevel').textContent = levelNumber;

        this.highlightActiveConfiguration();
        this.checkGameStatus();

        if (this.isUserLoggedIn) {
            await this.saveGameAuto();
        }

        this.saveLevelState();

        if (this.hintsEnabled) {
            this.cancelHintSolving();
        }
        this.updateUserStats();
    }

    resetBoard() {
        this.board = this.createBoard();
        this.selectedMarble = null;
    }

    setupEventListeners() {
        document.getElementById('saveBtn').onclick = () => this.saveGame();
        document.getElementById('resetBtn').onclick = () => this.resetGame();
        document.getElementById('undoBtn').onclick = () => this.undoMove();
        document.getElementById('shareBtn').onclick = () => this.showShareModal();
        document.getElementById('downloadShareBtn').onclick = () => this.downloadShareImage();
        document.getElementById('nativeShareBtn').onclick = () => this.nativeShare();
        document.getElementById('hintBtn').onclick = () => this.toggleHints();
        document.getElementById('diagonalBtn').onclick = () => this.toggleDiagonals();

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey || e.altKey || e.target.closest('input, textarea, select')) return;
            if (e.key === 'h') {
                this.toggleHints();
            } else if (e.key === 'd') {
                this.toggleDiagonals();
            }
        });
    }

    renderBoard() {
        const boardElement = document.getElementById('gameBoard');
        boardElement.innerHTML = '';

        const shape = this.shapes[this.currentShape];
        const rows = shape.rows;
        const cols = shape.cols;
        boardElement.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = i;
                cell.dataset.col = j;

                if (!this._isValidCell(i, j)) {
                    cell.classList.add('invalid');
                }

                if (this.board[i] && this.board[i][j]) {
                    cell.classList.add('marble');
                    cell.textContent = '\u25CF';
                }

                const isHintSelected = this.currentHint && this.selectedMarble &&
                    this.selectedMarble.row === this.currentHint.from_row &&
                    this.selectedMarble.col === this.currentHint.from_col;

                if (this.selectedMarble && this.selectedMarble.row === i && this.selectedMarble.col === j) {
                    cell.classList.add(isHintSelected ? 'hint-source' : 'selected');
                }

                if (this.isValidMove(i, j) && !(this.board[i] && this.board[i][j])) {
                    cell.classList.add('valid-move');
                }

                if (isHintSelected && i === this.currentHint.to_row && j === this.currentHint.to_col) {
                    cell.classList.add('hint-destination');
                }

                cell.onclick = () => this.handleCellClick(i, j);
                boardElement.appendChild(cell);
            }
        }
    }

    handleCellClick(row, col) {
        if (this.board[row] && this.board[row][col]) {
            this.selectedMarble = { row, col };
        } else if (this.selectedMarble && this.isValidMove(row, col)) {
            this.makeMove(this.selectedMarble.row, this.selectedMarble.col, row, col);
            this.selectedMarble = null;
        }

        this.updateDisplay();
    }

    isValidMove(toRow, toCol) {
        if (!this.selectedMarble) return false;
        if (!this._isValidCell(toRow, toCol)) return false;

        const { row: fromRow, col: fromCol } = this.selectedMarble;

        const rowDiff = Math.abs(toRow - fromRow);
        const colDiff = Math.abs(toCol - fromCol);

        const isOrthogonal = (rowDiff === 2 && colDiff === 0) || (rowDiff === 0 && colDiff === 2);
        const isDiagonal = this.allowDiagonals && rowDiff === 2 && colDiff === 2;
        if (isOrthogonal || isDiagonal) {
            const jumpRow = fromRow + (toRow - fromRow) / 2;
            const jumpCol = fromCol + (toCol - fromCol) / 2;

            return this.board[jumpRow] && this.board[jumpRow][jumpCol];
        }

        return false;
    }

    async makeMove(fromRow, fromCol, toRow, toCol) {
        const jumpRow = fromRow + (toRow - fromRow) / 2;
        const jumpCol = fromCol + (toCol - fromCol) / 2;

        this.board[fromRow][fromCol] = false;
        this.board[jumpRow][jumpCol] = false;
        this.board[toRow][toCol] = true;

        const move = {
            from: { row: fromRow, col: fromCol },
            to: { row: toRow, col: toCol },
            jumped: { row: jumpRow, col: jumpCol }
        };
        this.moveHistory.push(move);

        this.updateMoveHistory();
        this.checkGameStatus();

        this.hasUnsavedChanges = true;
        this.updateSaveButtonState();

        if (this.isUserLoggedIn) {
            await this.saveGameAuto();
        }

        this.saveLevelState();

        if (this.hintsEnabled) {
            this.cancelHintSolving();
        }
        this.updateUserStats();
    }

    updateDisplay() {
        this.renderBoard();
        this.updateStats();
    }

    updateStats() {
        const marblesLeft = this.countMarbles();
        const movesCount = this.moveHistory.length;

        document.getElementById('marblesLeft').textContent = marblesLeft;
        document.getElementById('movesCount').textContent = movesCount;

        let status = 'Playing';
        if (marblesLeft === 1) {
            status = 'Won!';
        } else if (marblesLeft > 1 && !this.hasValidMoves()) {
            status = 'Stuck';
        }

        document.getElementById('gameStatus').textContent = status;
    }

    countMarbles() {
        let count = 0;
        const shape = this.shapes[this.currentShape];
        const rows = shape ? shape.rows : 9;
        const cols = shape ? shape.cols : 9;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (this.board[i] && this.board[i][j]) count++;
            }
        }
        return count;
    }

    hasValidMoves() {
        const shape = this.shapes[this.currentShape];
        const rows = shape ? shape.rows : 9;
        const cols = shape ? shape.cols : 9;
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                if (this.board[i] && this.board[i][j]) {
                    let directions = [[-2, 0], [2, 0], [0, -2], [0, 2]];
                    if (this.allowDiagonals) {
                        directions = directions.concat([[-2, -2], [-2, 2], [2, -2], [2, 2]]);
                    }
                    for (const [dRow, dCol] of directions) {
                        const toRow = i + dRow;
                        const toCol = j + dCol;
                        if (toRow >= 0 && toRow < rows && toCol >= 0 && toCol < cols && this._isValidCell(toRow, toCol)) {
                            if (!(this.board[toRow] && this.board[toRow][toCol])) {
                                const jumpRow = i + dRow / 2;
                                const jumpCol = j + dCol / 2;
                                if (this.board[jumpRow] && this.board[jumpRow][jumpCol]) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    checkGameStatus() {
        const marblesLeft = this.countMarbles();
        const stateKey = this._stateKey(this.currentConfig);
        if (marblesLeft === 1) {
            if (this.isUserLoggedIn) {
                this.markLevelCompleted(this.currentConfig);
            }
            this.showShareButton();
        } else if (marblesLeft > 1 && !this.hasValidMoves()) {
            this.hideShareButton();
        } else {
            if (this.completedLevels.includes(stateKey)) {
                this.showShareButton();
            } else {
                this.hideShareButton();
            }
        }
    }

    updateMoveHistory() {
        const container = document.getElementById('moveHistory');
        container.innerHTML = '';

        if (this.moveHistory.length === 0) {
            container.innerHTML = '<p class="text-muted text-center">No moves yet</p>';
            return;
        }

        this.moveHistory.forEach((move, index) => {
            const div = document.createElement('div');
            div.className = 'move-item';
            div.textContent = `Move ${index + 1}: (${move.from.row},${move.from.col}) \u2192 (${move.to.row},${move.to.col})`;
            container.appendChild(div);
        });

        container.scrollTop = container.scrollHeight;
    }

    resetGame() {
        const stateKey = this._stateKey(this.currentConfig);
        if (this.completedLevels.includes(stateKey)) {
            this.completedLevels = this.completedLevels.filter(level => level !== stateKey);
        }

        this.clearLevelState(this.currentConfig);
        this.resetBoard();
        this.clearHistory();
        this.loadConfiguration(this.currentConfig, false);
        this.hideShareButton();

        if (this.hintsEnabled) {
            this.cancelHintSolving();
        }
        this.updateUserStats();
    }

    async undoMove() {
        if (this.moveHistory.length === 0) return;

        const lastMove = this.moveHistory.pop();

        this.board[lastMove.from.row][lastMove.from.col] = true;
        this.board[lastMove.jumped.row][lastMove.jumped.col] = true;
        this.board[lastMove.to.row][lastMove.to.col] = false;

        this.selectedMarble = null;
        this.updateDisplay();
        this.updateMoveHistory();

        this.hasUnsavedChanges = true;
        this.updateSaveButtonState();

        if (this.isUserLoggedIn) {
            await this.saveGameAuto();
        }

        this.saveLevelState();

        if (this.hintsEnabled) {
            this.cancelHintSolving();
        }
        this.updateUserStats();
    }

    clearHistory() {
        this.moveHistory = [];
        this.updateMoveHistory();
    }

    highlightActiveConfiguration() {
        document.querySelectorAll('.config-item').forEach(item => {
            item.classList.remove('active');
        });

        const configItems = document.querySelectorAll('.config-item');
        const keys = Object.keys(this.configurations);
        configItems.forEach((item, index) => {
            if (keys[index] === this.currentConfig) {
                item.classList.add('active');
            }
        });
    }

    async checkUserLoginStatus() {
        try {
            const response = await fetch('/api/auth/status');
            if (response.ok) {
                const authData = await response.json();
                const wasLoggedIn = this.isUserLoggedIn;
                this.isUserLoggedIn = authData.authenticated;
                this.userEmail = authData.email;
                this.userName = authData.name;

                if (wasLoggedIn && !this.isUserLoggedIn) {
                    this.showSessionExpiredNotification();
                    this.clearSessionStorage();
                    this.loadConfiguration(this.currentConfig, true);
                    this.updateDisplay();
                    this.updateMoveHistory();
                }

                if (this.isUserLoggedIn) {
                    this.refreshSession();
                }
            } else {
                this.isUserLoggedIn = false;
                this.userEmail = null;
                this.userName = null;
            }
        } catch (error) {
            console.error('Error checking login status:', error);
            this.isUserLoggedIn = false;
            this.userEmail = null;
            this.userName = null;
        }
        this.updateSaveButtonState();
    }

    async refreshSession() {
        try {
            const response = await fetch('/api/auth/refresh-session', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            if (response.ok) {
                console.log('Session refreshed successfully');
            }
        } catch (error) {
            console.error('Error refreshing session:', error);
        }
    }

    setupActivityTracking() {
        let activityTimeout;
        const resetActivity = () => {
            clearTimeout(activityTimeout);
            activityTimeout = setTimeout(() => {
                console.log('User inactive, skipping session refresh');
            }, 5 * 60 * 1000);
        };

        ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'].forEach(event => {
            document.addEventListener(event, resetActivity, true);
        });

        resetActivity();
    }

    showSessionExpiredNotification() {
        this.saveGameStateToLocalStorage();
        this.clearSessionStorage();

        const notification = document.createElement('div');
        notification.className = 'alert alert-warning alert-dismissible fade show position-fixed';
        notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
        notification.innerHTML = `
            <strong>Session Expired</strong><br>
            Your session has expired. Your progress has been saved locally. Please log in again to save to the server.
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;

        document.body.appendChild(notification);

        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 10000);
    }

    saveGameStateToLocalStorage() {
        try {
            const gameState = {
                levelStates: this.levelStates,
                completedLevels: this.completedLevels,
                currentConfig: this.currentConfig,
                currentShape: this.currentShape,
                board: this.board,
                moveHistory: this.moveHistory,
                timestamp: Date.now()
            };
            localStorage.setItem('skippingStones_backup', JSON.stringify(gameState));
            console.log('Game state saved to localStorage as backup');
        } catch (error) {
            console.error('Error saving to localStorage:', error);
        }
    }

    loadGameStateFromLocalStorage() {
        try {
            const backup = localStorage.getItem('skippingStones_backup');
            if (backup) {
                const gameState = JSON.parse(backup);
                const backupAge = Date.now() - gameState.timestamp;

                if (backupAge < 24 * 60 * 60 * 1000) {
                    this.levelStates = gameState.levelStates || {};
                    this.completedLevels = gameState.completedLevels || [];
                    this.currentConfig = gameState.currentConfig || 'level1';
                    this.board = gameState.board || [];
                    this.moveHistory = gameState.moveHistory || [];

                    // Restore shape
                    if (gameState.currentShape && this.shapes[gameState.currentShape]) {
                        this.currentShape = gameState.currentShape;
                        this._rebuildValidCellsSet();
                        this.configurations = this.shapes[this.currentShape].levels;
                        this.renderShapeSelector();
                        this.renderConfigurations();
                    }

                    console.log('Restored game state from localStorage backup');
                    this.updateDisplay();
                    this.updateMoveHistory();
                    return true;
                } else {
                    localStorage.removeItem('skippingStones_backup');
                }
            }
        } catch (error) {
            console.error('Error loading from localStorage:', error);
        }
        return false;
    }

    async loadUserGameState() {
        try {
            console.log('Loading user game state...');

            const allLevelsResponse = await fetch('/api/game-state/load-all-levels');

            if (allLevelsResponse.ok) {
                const allLevelsState = await allLevelsResponse.json();

                const serverLevelStates = allLevelsState.level_states || {};
                this.completedLevels = allLevelsState.completed_levels || [];

                // Migrate old keys: "level1" -> "wiegleb:level1"
                const migratedStates = {};
                for (const [key, val] of Object.entries(serverLevelStates)) {
                    if (!key.includes(':')) {
                        migratedStates[`wiegleb:${key}`] = val;
                    } else {
                        migratedStates[key] = val;
                    }
                }
                this.levelStates = migratedStates;

                // Migrate old completed levels
                this.completedLevels = this.completedLevels.map(l =>
                    l.includes(':') ? l : `wiegleb:${l}`
                );

                // Determine current shape and config from saved state
                const savedLevel = allLevelsState.current_level || 'level1';
                const savedShape = allLevelsState.current_shape || 'wiegleb';
                if (this.shapes[savedShape]) {
                    this.currentShape = savedShape;
                    this._rebuildValidCellsSet();
                    this.configurations = this.shapes[this.currentShape].levels;
                    this.renderShapeSelector();
                    this.renderConfigurations();
                }
                this.currentConfig = savedLevel;

                this.validateLevelStates();

                const stateKey = this._stateKey(this.currentConfig);
                const currentLevelState = this.levelStates[stateKey];

                if (currentLevelState) {
                    this.board = currentLevelState.board;
                    this.moveHistory = currentLevelState.moveHistory || [];
                    this.updateDisplay();
                    this.updateMoveHistory();
                } else {
                    this.loadConfiguration(this.currentConfig, true);
                }

                const levelNumber = this.currentConfig.replace('level', '');
                document.getElementById('currentLevel').textContent = levelNumber;
                this.highlightActiveConfiguration();
                this.checkGameStatus();

            } else {
                console.log('All levels load failed, trying fallback...');
                const response = await fetch('/api/game-state/load');
                if (response.ok) {
                    const gameState = await response.json();

                    this.currentConfig = gameState.current_level || 'level1';
                    this.completedLevels = (gameState.completed_levels || []).map(l =>
                        l.includes(':') ? l : `wiegleb:${l}`
                    );

                    if (gameState.board_state && gameState.board_state.length > 0) {
                        this.board = gameState.board_state;
                        this.moveHistory = gameState.move_history || [];
                        this.updateMoveHistory();
                        this.updateDisplay();
                        this.highlightActiveConfiguration();

                        const levelNumber = this.currentConfig.replace('level', '');
                        document.getElementById('currentLevel').textContent = levelNumber;
                    } else {
                        this.loadConfiguration(this.currentConfig);
                    }
                } else {
                    this.loadConfiguration(this.currentConfig);
                }
            }
        } catch (error) {
            console.error('Error loading user game state:', error);
            this.loadConfiguration(this.currentConfig);
        }
    }

    async saveGameAuto() {
        if (!this.isUserLoggedIn) return;

        try {
            const stateKey = this._stateKey(this.currentConfig);
            this.levelStates[stateKey] = {
                board: this.board,
                moveHistory: this.moveHistory
            };

            const allLevelsState = {
                level_states: this.levelStates,
                completed_levels: this.completedLevels,
                current_level: this.currentConfig,
                current_shape: this.currentShape,
                user_email: this.userEmail || '',
                user_name: this.userName || ''
            };

            const response = await fetch('/api/game-state/save-all-levels', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(allLevelsState)
            });

            if (response.ok) {
                this.hasUnsavedChanges = false;
                this.updateSaveButtonState();

                const saveBtn = document.getElementById('saveBtn');
                saveBtn.innerHTML = '<i class="fas fa-check me-2"></i>Saved!';
                saveBtn.classList.remove('btn-success');
                saveBtn.classList.add('btn-success');
            } else if (response.status === 401) {
                return;
            }
        } catch (error) {
            console.error('Error auto-saving game:', error);
        }
    }

    async saveGame() {
        if (!this.isUserLoggedIn) {
            alert('Please log in to save your game progress.');
            return;
        }

        try {
            const stateKey = this._stateKey(this.currentConfig);
            this.levelStates[stateKey] = {
                board: this.board,
                moveHistory: this.moveHistory
            };

            const allLevelsState = {
                level_states: this.levelStates,
                completed_levels: this.completedLevels,
                current_level: this.currentConfig,
                current_shape: this.currentShape,
                user_email: this.userEmail || '',
                user_name: this.userName || ''
            };

            const response = await fetch('/api/game-state/save-all-levels', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(allLevelsState)
            });

            if (response.ok) {
                this.hasUnsavedChanges = false;
                this.updateSaveButtonState();

                const saveBtn = document.getElementById('saveBtn');
                saveBtn.innerHTML = '<i class="fas fa-check me-2"></i>Saved!';
                saveBtn.classList.remove('btn-success');
                saveBtn.classList.add('btn-success');
            } else if (response.status === 401) {
                this.isUserLoggedIn = false;
                this.userEmail = null;
                this.userName = null;
                this.updateSaveButtonState();
                this.showSessionExpiredNotification();

                if (confirm('Your session has expired. Would you like to log in again to save your progress?')) {
                    window.location.href = '/login';
                }
                return;
            } else {
                alert('Failed to save game. Please try again.');
            }
        } catch (error) {
            console.error('Error saving game:', error);
            alert('Failed to save game. Please try again.');
        }
    }

    async markLevelCompleted(configKey) {
        if (!this.isUserLoggedIn) return;

        try {
            const stateKey = this._stateKey(configKey);
            if (!this.completedLevels.includes(stateKey)) {
                this.completedLevels.push(stateKey);
            }

            this.levelStates[stateKey] = {
                ...this.levelStates[stateKey],
                completed: true,
                completionBoard: JSON.parse(JSON.stringify(this.board)),
                completionMoves: JSON.parse(JSON.stringify(this.moveHistory)),
                completionMarblesLeft: this.countMarbles()
            };

            await this.saveGame();
            this.updateUserStats();
            this.renderConfigurations();
            this.highlightActiveConfiguration();
        } catch (error) {
            console.error('Error marking level as completed:', error);
        }
    }

    toggleHints() {
        if (this.hintsEnabled) {
            this.cancelHintSolving();
            this.renderBoard();
        } else {
            this.hintsEnabled = true;
            this.updateHintButtonState();
            this.fetchHint();
        }
    }

    cancelHintSolving() {
        this.hintsEnabled = false;
        this.hintRequestId++;
        document.getElementById('hintBtn').innerHTML = '<i class="fas fa-lightbulb me-2"></i>Hint';
        this.clearHint();
        this.updateHintButtonState();
    }

    updateHintButtonState() {
        const btn = document.getElementById('hintBtn');
        if (this.hintsEnabled) {
            btn.classList.remove('btn-outline-info');
            btn.classList.add('btn-info');
        } else {
            btn.classList.remove('btn-info');
            btn.classList.add('btn-outline-info');
        }
    }

    toggleDiagonals() {
        this.allowDiagonals = !this.allowDiagonals;
        this.updateDiagonalButtonState();
        this.cancelHintSolving();
        this.updateDisplay();
        this.saveLevelState();
    }

    updateDiagonalButtonState() {
        const btn = document.getElementById('diagonalBtn');
        if (this.allowDiagonals) {
            btn.classList.remove('btn-outline-secondary');
            btn.classList.add('btn-secondary');
        } else {
            btn.classList.remove('btn-secondary');
            btn.classList.add('btn-outline-secondary');
        }
    }

    async fetchHint() {
        if (!this.hintsEnabled) return;
        const requestId = ++this.hintRequestId;
        const hintBtn = document.getElementById('hintBtn');

        try {
            hintBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Solving...';

            const response = await fetch('/api/skipping-stones/hint', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ board: this.board, shape_id: this.currentShape, allow_diagonals: this.allowDiagonals })
            });
            if (requestId !== this.hintRequestId) return;
            if (!response.ok) {
                this.currentHint = null;
                return;
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (requestId !== this.hintRequestId) return;
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();

                for (const line of lines) {
                    if (!line.trim()) continue;
                    let msg;
                    try {
                        msg = JSON.parse(line);
                    } catch (e) {
                        console.warn('Skipping malformed hint JSON:', line);
                        continue;
                    }
                    if (msg.type === 'progress') {
                        const elapsed = Math.floor(msg.elapsed);
                        hintBtn.innerHTML = `<i class="fas fa-spinner fa-spin me-2"></i>Solving... ${elapsed}s`;
                    } else if (msg.type === 'result') {
                        this.currentHint = msg.hint;
                        if (this.currentHint) {
                            this.selectedMarble = { row: this.currentHint.from_row, col: this.currentHint.from_col };
                        } else {
                            this.hintsEnabled = false;
                            this.updateHintButtonState();
                            if (msg.no_solution) {
                                this.showHintNotification('No solution exists from this position.', 'info');
                            } else if (msg.queued && msg.timed_out) {
                                this.showHintNotification('Solver timed out. Queued for background solving \u2014 check back later.', 'warning');
                            } else if (msg.queued) {
                                this.showHintNotification('Queued for background solving. Check back later.', 'info');
                            } else if (msg.timed_out) {
                                this.showHintNotification('Solver timed out.', 'warning');
                            } else {
                                this.showHintNotification('No solution found from this position.', 'info');
                            }
                        }
                    }
                }
            }
        } catch (error) {
            if (requestId !== this.hintRequestId) return;
            console.error('Error fetching hint:', error);
            this.currentHint = null;
        } finally {
            if (requestId === this.hintRequestId) {
                hintBtn.innerHTML = '<i class="fas fa-lightbulb me-2"></i>Hint';
                this.renderBoard();
            }
        }
    }

    clearHint() {
        if (this.currentHint && this.selectedMarble &&
            this.selectedMarble.row === this.currentHint.from_row &&
            this.selectedMarble.col === this.currentHint.from_col) {
            this.selectedMarble = null;
        }
        this.currentHint = null;
    }

    showHintNotification(message, type) {
        const existing = document.getElementById('hintNotification');
        if (existing) existing.remove();

        const alert = document.createElement('div');
        alert.id = 'hintNotification';
        alert.className = `alert alert-${type} alert-dismissible fade show mt-2 mb-0 py-2 px-3`;
        alert.style.fontSize = '0.85em';
        alert.innerHTML = `${message}<button type="button" class="btn-close btn-close-sm" data-bs-dismiss="alert"></button>`;

        const hintBtn = document.getElementById('hintBtn');
        hintBtn.parentNode.insertBefore(alert, hintBtn.nextSibling);

        setTimeout(() => { if (alert.parentNode) alert.remove(); }, 5000);
    }

    getGameStatus() {
        const marblesLeft = this.countMarbles();
        if (marblesLeft === 1) {
            return 'Won!';
        } else if (marblesLeft > 1 && !this.hasValidMoves()) {
            return 'Stuck';
        }
        return 'Playing';
    }

    updateUserStats() {
        if (!this.isUserLoggedIn) {
            document.getElementById('userStatsCard').style.display = 'none';
            return;
        }

        document.getElementById('userStatsCard').style.display = 'block';
        const completedCount = this.completedLevels.length;
        // Count total levels across all shapes
        let totalLevels = 0;
        for (const shapeId of this.shapeOrder) {
            totalLevels += Object.keys(this.shapes[shapeId].levels).length;
        }
        const progressPercentage = totalLevels > 0 ? (completedCount / totalLevels) * 100 : 0;

        document.getElementById('completedLevels').textContent = completedCount;
        document.getElementById('totalLevels').textContent = totalLevels;
        document.getElementById('progressBar').style.width = `${progressPercentage}%`;
        document.getElementById('progressBar').setAttribute('aria-valuenow', progressPercentage);
    }

    updateSaveButtonState() {
        const saveBtn = document.getElementById('saveBtn');
        if (!this.isUserLoggedIn) {
            saveBtn.disabled = false;
            saveBtn.innerHTML = '<i class="fab fa-google me-2"></i>Login';
            saveBtn.classList.remove('btn-success', 'btn-warning');
            saveBtn.classList.add('btn-primary', 'google-login-game-btn');
            saveBtn.title = 'Please log in to save your game';
            saveBtn.onclick = () => window.location.href = '/login';
        } else {
            saveBtn.onclick = () => this.saveGame();
            saveBtn.classList.remove('google-login-game-btn');
            if (this.hasUnsavedChanges) {
                saveBtn.innerHTML = '<i class="fas fa-save me-2"></i>Save*';
                saveBtn.classList.remove('btn-success', 'btn-outline-light');
                saveBtn.classList.add('btn-warning');
                saveBtn.title = 'Save progress for all levels (unsaved changes)';
            } else {
                saveBtn.innerHTML = '<i class="fas fa-check me-2"></i>Saved!';
                saveBtn.classList.remove('btn-warning', 'btn-outline-light');
                saveBtn.classList.add('btn-success');
                saveBtn.title = 'All progress saved';
            }
        }
    }

    showShareButton() {
        const shareBtn = document.getElementById('shareBtn');
        shareBtn.style.display = 'inline-block';
        shareBtn.classList.add('btn-info');
        shareBtn.classList.remove('btn-secondary');
    }

    hideShareButton() {
        const shareBtn = document.getElementById('shareBtn');
        shareBtn.style.display = 'none';
    }

    async showShareModal() {
        if (!this.isUserLoggedIn) {
            alert('Please log in to share your achievements.');
            return;
        }

        const stateKey = this._stateKey(this.currentConfig);
        if (!this.completedLevels.includes(stateKey)) {
            alert('This level has not been completed yet. Complete the level to share your achievement!');
            return;
        }

        const modal = new bootstrap.Modal(document.getElementById('shareModal'));
        modal.show();

        const nativeShareBtn = document.getElementById('nativeShareBtn');
        if (navigator.share) {
            nativeShareBtn.style.display = 'inline-block';
        } else {
            nativeShareBtn.style.display = 'none';
        }

        try {
            const levelState = this.levelStates[stateKey];
            let boardState = this.board;
            let movesCount = this.moveHistory.length;
            let marblesLeft = this.countMarbles();

            if (levelState && levelState.completed && levelState.completionBoard) {
                boardState = levelState.completionBoard;
                movesCount = levelState.completionMoves ? levelState.completionMoves.length : this.moveHistory.length;
                marblesLeft = levelState.completionMarblesLeft || 1;
            }

            const response = await fetch('/api/share/level-completed', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    level: this.currentConfig,
                    shape_id: this.currentShape,
                    board_state: boardState,
                    moves_count: movesCount,
                    marbles_left: marblesLeft
                })
            });

            if (response.ok) {
                const data = await response.json();
                this.displayShareImage(data.image_data, data.level_name);
            } else {
                throw new Error('Failed to generate share image');
            }
        } catch (error) {
            console.error('Error generating share image:', error);
            document.getElementById('shareImageContainer').innerHTML =
                '<p class="text-danger">Failed to generate share image. Please try again.</p>';
        }
    }

    displayShareImage(imageData, levelName) {
        const container = document.getElementById('shareImageContainer');
        container.innerHTML = `
            <h6 class="mb-3">${levelName} Completed!</h6>
            <img src="data:image/png;base64,${imageData}"
                 alt="Shareable achievement image"
                 class="img-fluid rounded shadow"
                 style="max-width: 100%; max-height: 500px;">
            <p class="text-muted mt-3">Share this image to show off your achievement!</p>
        `;

        this.currentShareImageData = imageData;
    }

    downloadShareImage() {
        if (!this.currentShareImageData) return;

        const link = document.createElement('a');
        link.href = `data:image/png;base64,${this.currentShareImageData}`;
        link.download = `skipping-stones-achievement-${this.currentShape}-${this.currentConfig}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    async nativeShare() {
        if (!this.currentShareImageData) return;

        try {
            const response = await fetch(`data:image/png;base64,${this.currentShareImageData}`);
            const blob = await response.blob();

            const file = new File([blob], `skipping-stones-achievement-${this.currentShape}-${this.currentConfig}.png`, {
                type: 'image/png'
            });

            const shareData = {
                title: `Skipping Stones Achievement - ${this.currentConfig}`,
                text: `I completed ${this.currentConfig} in Skipping Stones! Check out my achievement!`,
                files: [file]
            };

            await navigator.share(shareData);

            const nativeShareBtn = document.getElementById('nativeShareBtn');
            const originalText = nativeShareBtn.innerHTML;
            nativeShareBtn.innerHTML = '<i class="fas fa-check me-2"></i>Shared!';
            nativeShareBtn.classList.remove('btn-info');
            nativeShareBtn.classList.add('btn-success');

            setTimeout(() => {
                nativeShareBtn.innerHTML = originalText;
                nativeShareBtn.classList.remove('btn-success');
                nativeShareBtn.classList.add('btn-info');
            }, 2000);

        } catch (error) {
            console.error('Error sharing image:', error);

            if (error.name !== 'AbortError') {
                const container = document.getElementById('shareImageContainer');
                const currentContent = container.innerHTML;
                container.innerHTML = `
                    ${currentContent}
                    <div class="alert alert-warning mt-3">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        Failed to share image. Please try downloading instead.
                    </div>
                `;

                setTimeout(() => {
                    container.innerHTML = currentContent;
                }, 5000);
            }
        }
    }
}

// Initialize the game when the page loads
document.addEventListener('DOMContentLoaded', () => {
    const game = new SkippingStonesGame();

    window.addEventListener('beforeunload', () => {
        if (game.isUserLoggedIn) {
            game.clearSessionStorage();
        }
    });

    const logoutLink = document.querySelector('a[href*="logout"]');
    if (logoutLink) {
        logoutLink.addEventListener('click', async (e) => {
            e.preventDefault();

            if (game.isUserLoggedIn) {
                try {
                    const response = await fetch('/api/auth/logout', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (response.ok) {
                        game.clearSessionStorage();
                        localStorage.removeItem('skippingStones_backup');
                        game.isUserLoggedIn = false;
                        game.userEmail = null;
                        game.userName = null;
                        game.updateSaveButtonState();
                        window.location.href = '/logout';
                    } else {
                        window.location.href = '/logout';
                    }
                } catch (error) {
                    console.error('Error during logout:', error);
                    window.location.href = '/logout';
                }
            } else {
                window.location.href = '/logout';
            }
        });
    }

    const switchAccountLink = document.querySelector('a[href*="switch-account"]');
    if (switchAccountLink) {
        switchAccountLink.addEventListener('click', (e) => {
            game.clearSessionStorage();
            localStorage.removeItem('skippingStones_backup');
        });
    }

    setInterval(() => {
        if (game.isUserLoggedIn) {
            game.checkUserLoginStatus();
        }
    }, 15 * 60 * 1000);
});
</script>
{% endblock %}
